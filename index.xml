<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>赵凯的博客 on 赵凯的博客</title>
    <link>https://1060146865.github.io/</link>
    <description>Recent content in 赵凯的博客 on 赵凯的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-ch</language>
    <lastBuildDate>Mon, 17 Aug 2020 17:53:29 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>JS 防抖和节流</title>
      <link>https://1060146865.github.io/2020/js%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</link>
      <pubDate>Mon, 17 Aug 2020 17:53:29 +0800</pubDate>
      
      <guid>https://1060146865.github.io/2020/js%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</guid>
      <description>

&lt;h3 id=&#34;是什么&#34;&gt;是什么&lt;/h3&gt;

&lt;p&gt;本质上是优化高频率执行代码的一种手段&lt;/p&gt;

&lt;p&gt;如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能&lt;/p&gt;

&lt;p&gt;为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用throttle（防抖）和debounce（节流）的方式来减少调用频率&lt;/p&gt;

&lt;h3 id=&#34;定义&#34;&gt;定义&lt;/h3&gt;

&lt;p&gt;节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效&lt;/p&gt;

&lt;p&gt;防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时
一个经典的比喻:&lt;/p&gt;

&lt;p&gt;想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应&lt;/p&gt;

&lt;p&gt;假设电梯有两种运行策略 debounce 和 throttle，超时设定为15秒，不考虑容量限制&lt;/p&gt;

&lt;p&gt;电梯第一个人进来后，15秒后准时运送一次，这是节流&lt;/p&gt;

&lt;p&gt;电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖&lt;/p&gt;

&lt;h3 id=&#34;代码实现&#34;&gt;代码实现&lt;/h3&gt;

&lt;h3 id=&#34;节流&#34;&gt;节流&lt;/h3&gt;

&lt;p&gt;完成节流可以使用时间戳与定时器的写法&lt;/p&gt;

&lt;p&gt;使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function throttled1(fn, delay = 500) {
    let oldtime = Date.now()
    return function (...args) {
        let newtime = Date.now()
        if (newtime - oldtime &amp;gt;= delay) {
            fn.apply(null, args)
            oldtime = Date.now()
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用定时器写法，delay毫秒后第一次执行，第二次事件停止触发后依然会再一次执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function throttled2(fn, delay = 500) {
    let timer = null
    return function (...args) {
        if (!timer) {
            timer = setTimeout(() =&amp;gt; {
                fn.apply(this, args)
                timer = null
            }, delay);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以将时间戳写法的特性与定时器写法的特性相结合，实现一个更加精确的节流。实现如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function throttled(fn, delay) {
    let timer = null
    let starttime = Date.now()
    return function () {
        let curTime = Date.now() // 当前时间
        let remaining = delay - (curTime - starttime)  // 从上一次到现在，还剩下多少多余时间
        let context = this
        let args = arguments
        clearTimeout(timer)
        if (remaining &amp;lt;= 0) {
            fn.apply(context, args)
            starttime = Date.now()
        } else {
            timer = setTimeout(fn, remaining);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;防抖&#34;&gt;防抖&lt;/h3&gt;

&lt;p&gt;简单版本的实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function debounce(func, wait) {
    let timeout;

    return function () {
        let context = this; // 保存this指向
        let args = arguments; // 拿到event对象

        clearTimeout(timeout)
        timeout = setTimeout(function(){
            func.apply(context, args)
        }, wait);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;防抖如果需要立即执行，可加入第三个参数用于判断，实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function debounce(func, wait, immediate) {

    let timeout;

    return function () {
        let context = this;
        let args = arguments;

        if (timeout) clearTimeout(timeout); // timeout 不为null
        if (immediate) {
            let callNow = !timeout; // 第一次会立即执行，以后只有事件执行后才会再次触发
            timeout = setTimeout(function () {
                timeout = null;
            }, wait)
            if (callNow) {
                func.apply(context, args)
            }
        }
        else {
            timeout = setTimeout(function () {
                func.apply(context, args)
            }, wait);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;区别&#34;&gt;区别&lt;/h3&gt;

&lt;p&gt;相同点：&lt;/p&gt;

&lt;p&gt;都可以通过使用 setTimeout 实现&lt;/p&gt;

&lt;p&gt;目的都是，降低回调执行频率。节省计算资源
不同点：&lt;/p&gt;

&lt;p&gt;函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能&lt;/p&gt;

&lt;p&gt;函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次&lt;/p&gt;

&lt;p&gt;例如，都设置时间频率为500ms，在2秒时间内，频繁触发函数，节流，每隔 500ms 就执行一次。防抖，则不管调动多少次方法，在2s后，只会执行一次&lt;/p&gt;

&lt;h3 id=&#34;应用场景&#34;&gt;应用场景&lt;/h3&gt;

&lt;p&gt;防抖在连续的事件，只需触发一次回调的场景有：&lt;/p&gt;

&lt;p&gt;搜索框搜索输入。只需用户最后一次输入完，再发送请求
手机号、邮箱验证输入检测&lt;/p&gt;

&lt;p&gt;窗口大小resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。
节流在间隔一段时间执行一次回调的场景有：&lt;/p&gt;

&lt;p&gt;滚动加载，加载更多或滚到底部监听&lt;/p&gt;

&lt;p&gt;搜索框，搜索联想功能&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JS 宏任务微任务</title>
      <link>https://1060146865.github.io/2020/js-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%BE%AE%E4%BB%BB%E5%8A%A1/</link>
      <pubDate>Fri, 14 Aug 2020 13:23:29 +0800</pubDate>
      
      <guid>https://1060146865.github.io/2020/js-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%BE%AE%E4%BB%BB%E5%8A%A1/</guid>
      <description>

&lt;h3 id=&#34;js是单线程执行&#34;&gt;JS是单线程执行&lt;/h3&gt;

&lt;p&gt;&amp;ldquo;JS是单线程的&amp;rdquo;指的是JS 引擎线程。&lt;/p&gt;

&lt;p&gt;在浏览器环境中，有JS 引擎线程和渲染线程，且两个线程互斥。&lt;/p&gt;

&lt;p&gt;Node环境中，只有JS 线程。&lt;/p&gt;

&lt;h3 id=&#34;宿主&#34;&gt;宿主&lt;/h3&gt;

&lt;p&gt;JS运行的环境。一般为浏览器或者Node。&lt;/p&gt;

&lt;h3 id=&#34;执行栈&#34;&gt;执行栈&lt;/h3&gt;

&lt;p&gt;是一个存储函数调用的栈结构，遵循先进后出的原则。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://vkceyugu.cdn.bspapp.com/VKCEYUGU-a24cbdac-86d9-4b0a-b76a-ffd47ba57ff3/00e6366c-7a77-441a-8ba9-0e842b5e3be8.png&#34; alt=&#34;avatar&#34; /&gt;&lt;/p&gt;

&lt;p&gt;js是单线程的 只有一个调用栈 调用栈按照先入后出的规则进行 在执行调用栈的时候会先执行同步任务, 调用栈在发现异步任务的时候会把异步任务放到队列里面,异步任务列为宏任务队列和微任务队列,队列都按照先入先出的规则&lt;/p&gt;

&lt;p&gt;事件循环是一个不断循环的机制,不断的去寻找可执行任务来执行,在执行完同步任务以后,会先执行微任务队列的任务,把微任务队列的任务清空以后才会去执行宏任务,这个时候浏览器可能会渲染,渲染以后再去执行宏任务
宏任务settimeout()和setinterval()    微任务Promise.then().catch().finally()&lt;/p&gt;

&lt;p&gt;首先执行宏任务,在调用栈为空的时候,事件循环优先于执行微任务,清空微任务队列才会看一下需不需要渲染,渲染以后事件循环再执行下一轮宏任务,如果此时宏任务的其中一轮结束后,也就是调用栈清空的时候,事件循环又发现微任务,还会执行微任务,并且清空微任务队列才会看下需不需要渲染,渲染之后事件循环在此执行下一轮宏任务,在没有其余微任务的时候,宏任务就可以一直清空宏任务队列了&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JS this</title>
      <link>https://1060146865.github.io/2020/js-this/</link>
      <pubDate>Tue, 11 Aug 2020 13:13:29 +0800</pubDate>
      
      <guid>https://1060146865.github.io/2020/js-this/</guid>
      <description>

&lt;h1 id=&#34;this&#34;&gt;this&lt;/h1&gt;

&lt;p&gt;函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别&lt;/p&gt;

&lt;p&gt;在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定）&lt;/p&gt;

&lt;p&gt;this 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function baz() {
    // 当前调用栈是：baz
    // 因此，当前调用位置是全局作用域
    
    console.log( &amp;quot;baz&amp;quot; );
    bar(); // &amp;lt;-- bar的调用位置
}

function bar() {
    // 当前调用栈是：baz --&amp;gt; bar
    // 因此，当前调用位置在baz中
    
    console.log( &amp;quot;bar&amp;quot; );
    foo(); // &amp;lt;-- foo的调用位置
}

function foo() {
    // 当前调用栈是：baz --&amp;gt; bar --&amp;gt; foo
    // 因此，当前调用位置在bar中
    
    console.log( &amp;quot;foo&amp;quot; );
}

baz(); // &amp;lt;-- baz的调用位置

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时，this在函数执行过程中，this一旦被确定了，就不可以再更改&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = 10;
var obj = {
  a: 20
}

function fn() {
  this = obj; // 修改this，运行后会报错
  console.log(this.a);
}

fn();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;绑定规则&#34;&gt;绑定规则&lt;/h3&gt;

&lt;p&gt;根据不同的使用场合，this有不同的值，主要分为下面几种情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;默认绑定&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;隐式绑定&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;new绑定&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;显示绑定&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;默认绑定&#34;&gt;默认绑定&lt;/h3&gt;

&lt;p&gt;全局环境中定义person函数，内部使用this关键字&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var name = &#39;Jenny&#39;;
function person() {
    return this.name;
}
console.log(person());  //Jenny

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码输出Jenny，原因是调用函数的对象在游览器中位window，因此this指向window，所以输出Jenny&lt;/p&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;p&gt;严格模式下，不能将全局对象用于默认绑定，this会绑定到undefined，只有函数运行在非严格模式下，默认绑定才能绑定到全局对象&lt;/p&gt;

&lt;p&gt;#隐式绑定&lt;/p&gt;

&lt;h3 id=&#34;隐式绑定&#34;&gt;隐式绑定&lt;/h3&gt;

&lt;p&gt;函数还可以作为某个对象的方法调用，这时this就指这个上级对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function test() {
  console.log(this.x);
}

var obj = {};
obj.x = 1;
obj.m = test;

obj.m(); // 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var o = {
    a:10,
    b:{
        fn:function(){
            console.log(this.a); //undefined
        }
    }
}
o.b.fn();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码中，this的上一级对象为b，b内部并没有a变量的定义，所以输出undefined&lt;/p&gt;

&lt;p&gt;这里再举一种特殊情况&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var o = {
    a:10,
    b:{
        a:12,
        fn:function(){
            console.log(this.a); //undefined
            console.log(this); //window
        }
    }
}
var j = o.b.fn;
j();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时this指向的是window，这里的大家需要记住，this永远指向的是最后调用它的对象，虽然fn是对象b的方法，但是fn赋值给j时候并没有执行，所以最终指向window&lt;/p&gt;

&lt;h3 id=&#34;new绑定&#34;&gt;new绑定&lt;/h3&gt;

&lt;p&gt;通过构建函数new关键字生成一个实例对象，此时this指向这个实例对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function test() {
　this.x = 1;
}

var obj = new test();
obj.x // 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码之所以能过输出1，是因为new关键字改变了this的指向&lt;/p&gt;

&lt;p&gt;这里再列举一些特殊情况：&lt;/p&gt;

&lt;p&gt;new过程遇到return一个对象，此时this指向为返回的对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function fn()  
{  
    this.user = &#39;xxx&#39;;  
    return {};  
}
var a = new fn();  
console.log(a.user); //undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果返回一个简单类型的时候，则this指向实例对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function fn()  
{  
    this.user = &#39;xxx&#39;;  
    return 1;
}
var a = new fn;  
console.log(a.user); //xxx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意的是null虽然也是对象，但是此时new仍然指向实例对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function fn()  
{  
    this.user = &#39;xxx&#39;;  
    return null;
}
var a = new fn;  
console.log(a.user); //xxx
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;显示修改&#34;&gt;显示修改&lt;/h3&gt;

&lt;p&gt;apply()、call()、bind()是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时this指的就是这第一个参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-var&#34;&gt;function test() {
　console.log(this.x);
}

var obj = {};
obj.x = 1;
obj.m = test;
obj.m.apply(obj) // 1```


#三、箭头函数
在 ES6 的语法中还提供了箭头函语法，让我们在代码书写时就能确定 this 的指向（编译时绑定）

举个例子：

```const obj = {
  sayThis: () =&amp;gt; {
    console.log(this);
  }
};

obj.sayThis(); // window 因为 JavaScript 没有块作用域，所以在定义 sayThis 的时候，里面的 this 就绑到 window 上去了
const globalSay = obj.sayThis;
globalSay(); // window 浏览器中的 global 对象
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然箭头函数的this能够在编译的时候就确定了this的指向，但也需要注意一些潜在的坑&lt;/p&gt;

&lt;p&gt;下面举个例子：&lt;/p&gt;

&lt;p&gt;绑定事件监听&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const button = document.getElementById(&#39;mngb&#39;);
button.addEventListener(&#39;click&#39;, ()=&amp;gt; {
    console.log(this === window) // true
    this.innerHTML = &#39;clicked button&#39;
})

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述可以看到，我们其实是想要this为点击的button，但此时this指向了window&lt;/p&gt;

&lt;p&gt;包括在原型上添加方法时候，此时this指向window&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Cat.prototype.sayName = () =&amp;gt; {
    console.log(this === window) //true
    return this.name
}
const cat = new Cat(&#39;mm&#39;);
cat.sayName()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样的，箭头函数不能作为构建函数&lt;/p&gt;

&lt;h3 id=&#34;优先级&#34;&gt;优先级&lt;/h3&gt;

&lt;p&gt;隐式绑定 VS 显式绑定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo() {
    console.log( this.a );
}

var obj1 = {
    a: 2,
    foo: foo
};

var obj2 = {
    a: 3,
    foo: foo
};

obj1.foo(); // 2
obj2.foo(); // 3

obj1.foo.call( obj2 ); // 3
obj2.foo.call( obj1 ); // 2
显然，显示绑定的优先级更高

#new绑定 VS 隐式绑定
function foo(something) {
    this.a = something;
}

var obj1 = {
    foo: foo
};

var obj2 = {};

obj1.foo( 2 );
console.log( obj1.a ); // 2

obj1.foo.call( obj2, 3 );
console.log( obj2.a ); // 3

var bar = new obj1.foo( 4 );
console.log( obj1.a ); // 2
console.log( bar.a ); // 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，new绑定的优先级&amp;gt;隐式绑定&lt;/p&gt;

&lt;h3 id=&#34;new绑定-vs-显式绑定&#34;&gt;new绑定 VS 显式绑定&lt;/h3&gt;

&lt;p&gt;因为new和apply、call无法一起使用，但硬绑定也是显式绑定的一种，可以替换测试&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo(something) {
    this.a = something;
}

var obj1 = {};

var bar = foo.bind( obj1 );
bar( 2 );
console.log( obj1.a ); // 2

var baz = new bar( 3 );
console.log( obj1.a ); // 2
console.log( baz.a ); // 3

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;bar被绑定到obj1上，但是new bar(3) 并没有像我们预计的那样把obj1.a修改为3。但是，new修改了绑定调用bar()中的this&lt;/p&gt;

&lt;p&gt;我们可认为new绑定优先级&amp;gt;显式绑定&lt;/p&gt;

&lt;p&gt;&lt;code&gt;综上，new绑定优先级 &amp;gt; 显示绑定优先级 &amp;gt; 隐式绑定优先级 &amp;gt; 默认绑定优先级&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JS原型和原型链</title>
      <link>https://1060146865.github.io/2020/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</link>
      <pubDate>Mon, 10 Aug 2020 16:33:29 +0800</pubDate>
      
      <guid>https://1060146865.github.io/2020/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</guid>
      <description>

&lt;h1 id=&#34;原型&#34;&gt;原型&lt;/h1&gt;

&lt;p&gt;JavaScript 常被描述为一种基于原型的语言——每个对象拥有一个原型对象&lt;/p&gt;

&lt;p&gt;当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾&lt;/p&gt;

&lt;p&gt;准确地说，这些属性和方法定义在Object的构造器函数（constructor functions）之上的prototype属性上，而非实例对象本身&lt;/p&gt;

&lt;p&gt;下面举个例子：&lt;/p&gt;

&lt;p&gt;函数可以有属性。 每个函数都有一个特殊的属性叫作原型prototype&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function doSomething(){}
console.log( doSomething.prototype );


//控制台输出

{
    constructor: ƒ doSomething(),
    __proto__: {
        constructor: ƒ Object(),
        hasOwnProperty: ƒ hasOwnProperty(),
        isPrototypeOf: ƒ isPrototypeOf(),
        propertyIsEnumerable: ƒ propertyIsEnumerable(),
        toLocaleString: ƒ toLocaleString(),
        toString: ƒ toString(),
        valueOf: ƒ valueOf()
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个对象，就是大家常说的原型对象&lt;/p&gt;

&lt;p&gt;可以看到，原型对象有一个自有属性constructor，这个属性指向该函数，如下图关系展示&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://vkceyugu.cdn.bspapp.com/VKCEYUGU-a24cbdac-86d9-4b0a-b76a-ffd47ba57ff3/afe488ee-b7f0-42c2-bb95-2c512ea8dc8e.png&#34; alt=&#34;avatar&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;原型链&#34;&gt;原型链&lt;/h3&gt;

&lt;p&gt;原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法&lt;/p&gt;

&lt;p&gt;在对象实例和它的构造器之间建立一个链接（它是&lt;strong&gt;proto&lt;/strong&gt;属性，是从构造函数的prototype属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法&lt;/p&gt;

&lt;p&gt;下面举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Person(name) {
    this.name = name;
    this.age = 18;
    this.sayName = function() {
        console.log(this.name);
    }
}
// 第二步 创建实例
var person = new Person(&#39;person&#39;)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据代码，我们可以得到下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://vkceyugu.cdn.bspapp.com/VKCEYUGU-a24cbdac-86d9-4b0a-b76a-ffd47ba57ff3/7d07de23-aa92-4158-889e-8713b6f343bf.png&#34; alt=&#34;avatar&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下面分析一下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;构造函数Person存在原型对象Person.prototype&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;构造函数生成实例对象person，person的&lt;strong&gt;proto&lt;/strong&gt;指向构造函数Person原型对象&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Person.prototype.&lt;strong&gt;proto&lt;/strong&gt; 指向内置对象，因为 Person.prototype 是个对象，默认是由 Object函数作为类创建的，而 Object.prototype 为内置对象&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Person.&lt;strong&gt;proto&lt;/strong&gt; 指向内置匿名函数 anonymous，因为 Person 是个函数对象，默认由 Function 作为类创建&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Function.prototype 和 Function.&lt;strong&gt;proto&lt;/strong&gt;同时指向内置匿名函数 anonymous，这样原型链的终点就是 null&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;下面首先要看几个概念：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;proto&lt;/strong&gt;作为不同对象之间的桥梁，用来指向创建它的构造函数的原型对象的&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://vkceyugu.cdn.bspapp.com/VKCEYUGU-a24cbdac-86d9-4b0a-b76a-ffd47ba57ff3/2eccc2a4-f202-4793-b506-9f4b4acd7247.png&#34; alt=&#34;avatar&#34; /&gt;&lt;/p&gt;

&lt;p&gt;每个对象的&lt;strong&gt;proto&lt;/strong&gt;都是指向它的构造函数的原型对象prototype的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;person1.__proto__ === Person.prototype
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构造函数是一个函数对象，是通过 Function构造器产生的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Person.__proto__ === Function.prototype
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原型对象本身是一个普通对象，而普通对象的构造函数都是Object&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Person.prototype.__proto__ === Object.prototype
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;刚刚上面说了，所有的构造器都是函数对象，函数对象都是 Function构造产生的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Object.__proto__ === Function.prototype
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Object的原型对象也有&lt;strong&gt;proto&lt;/strong&gt;属性指向null，null是原型链的顶端&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Object.prototype.__proto__ === null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面作出总结：&lt;/p&gt;

&lt;p&gt;一切对象都是继承自Object对象，Object 对象直接继承根源对象null&lt;/p&gt;

&lt;p&gt;一切的函数对象（包括 Object 对象），都是继承自 Function 对象&lt;/p&gt;

&lt;p&gt;Object 对象直接继承自 Function 对象&lt;/p&gt;

&lt;p&gt;Function对象的&lt;strong&gt;proto&lt;/strong&gt;会指向自己的原型对象，最终还是继承自Object对象&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JS 闭包是什么？闭包的使用场景？</title>
      <link>https://1060146865.github.io/2020/js%E9%97%AD%E5%8C%85%E6%98%AF%E4%BB%80%E4%B9%88%E9%97%AD%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-copy/</link>
      <pubDate>Fri, 07 Aug 2020 14:23:29 +0800</pubDate>
      
      <guid>https://1060146865.github.io/2020/js%E9%97%AD%E5%8C%85%E6%98%AF%E4%BB%80%E4%B9%88%E9%97%AD%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-copy/</guid>
      <description>

&lt;h1 id=&#34;闭包是什么&#34;&gt;闭包是什么?&lt;/h1&gt;

&lt;p&gt;一个函数和对其周围状态的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包&lt;/p&gt;

&lt;p&gt;也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域&lt;/p&gt;

&lt;p&gt;在 JavaScript中，每当创建一个函数，闭包就会在函数创建的同时被创建出来，作为函数内部与外部连接起来的一座桥梁&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function init() {
    var name = &amp;quot;Mozilla&amp;quot;; // name 是一个被 init 创建的局部变量
    function displayName() { // displayName() 是内部函数，一个闭包
        alert(name); // 使用了父函数中声明的变量
    }
    displayName();
}
init();

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用场景&#34;&gt;使用场景&lt;/h3&gt;

&lt;p&gt;任何闭包的使用场景都离不开这两点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;创建私有变量&lt;/li&gt;
&lt;li&gt;延长变量的生命周期
一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;柯里化函数&#34;&gt;柯里化函数&lt;/h3&gt;

&lt;p&gt;柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 假设我们有一个求长方形面积的函数
function getArea(width, height) {
    return width * height
}
// 如果我们碰到的长方形的宽老是10
const area1 = getArea(10, 20)
const area2 = getArea(10, 30)
const area3 = getArea(10, 40)

// 我们可以使用闭包柯里化这个计算面积的函数
function getArea(width) {
    return height =&amp;gt; {
        return width * height
    }
}

const getTenWidthArea = getArea(10)
// 之后碰到宽度为10的长方形就可以这样计算面积
const area1 = getTenWidthArea(20)

// 而且如果遇到宽度偶尔变化也可以轻松复用
const getTwentyWidthArea = getArea(20)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用闭包模拟私有方法&#34;&gt;使用闭包模拟私有方法&lt;/h3&gt;

&lt;p&gt;在JavaScript中，没有支持声明私有变量，但我们可以使用闭包来模拟私有方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var Counter = (function() {
  var privateCounter = 0;
  function changeBy(val) {
    privateCounter += val;
  }
  return {
    increment: function() {
      changeBy(1);
    },
    decrement: function() {
      changeBy(-1);
    },
    value: function() {
      return privateCounter;
    }
  }
})();

var Counter1 = Counter;
var Counter2 = Counter;
console.log(Counter1.value()); /* logs 0 */
Counter1.increment();
Counter1.increment();
console.log(Counter1.value()); /* logs 2 */
Counter1.decrement();
console.log(Counter1.value()); /* logs 1 */
console.log(Counter2.value());

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述通过使用闭包来定义公共函数，并令其可以访问私有函数和变量，这种方式也叫模块方式&lt;/p&gt;

&lt;p&gt;两个计数器 Counter1 和 Counter2 是维护它们各自的独立性的，每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境，不会影响另一个闭包中的变量&lt;/p&gt;

&lt;h3 id=&#34;其他&#34;&gt;其他&lt;/h3&gt;

&lt;p&gt;例如计数器、延迟调用、回调等闭包的应用，其核心思想还是创建私有变量和延长变量的生命周期&lt;/p&gt;

&lt;h3 id=&#34;注意事项&#34;&gt;注意事项&lt;/h3&gt;

&lt;p&gt;如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响&lt;/p&gt;

&lt;p&gt;例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。&lt;/p&gt;

&lt;p&gt;原因在于每个对象的创建，方法都会被重新赋值&lt;/p&gt;

&lt;h3 id=&#34;优点-缺点&#34;&gt;优点/缺点&lt;/h3&gt;

&lt;p&gt;优点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期扎在内存中，可供之后使用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;避免变量污染全局&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;把变量存到独立的作用域，作为私有成员存在&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;缺点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对内存消耗有负面影响。因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以使用不当会导致内存泄漏&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对处理速度具有负面影响。闭包的层级决定了引用的外部变量在查找时经过的作用域链长度&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可能获取到意外的值(captured value)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>JS 深拷贝浅拷贝的区别？如何实现一个深拷贝？</title>
      <link>https://1060146865.github.io/2020/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%B7%B1%E6%8B%B7%E8%B4%9D/</link>
      <pubDate>Mon, 03 Aug 2020 11:24:29 +0800</pubDate>
      
      <guid>https://1060146865.github.io/2020/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%B7%B1%E6%8B%B7%E8%B4%9D/</guid>
      <description>

&lt;h1 id=&#34;javascript中存在两大数据类型&#34;&gt;JavaScript中存在两大数据类型：&lt;/h1&gt;

&lt;p&gt;基本类型
引用类型&lt;/p&gt;

&lt;p&gt;基本类型数据保存在在栈内存中&lt;/p&gt;

&lt;p&gt;引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中&lt;/p&gt;

&lt;h3 id=&#34;浅拷贝与深拷贝&#34;&gt;浅拷贝与深拷贝&lt;/h3&gt;

&lt;p&gt;浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址&lt;/p&gt;

&lt;p&gt;即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。&lt;/p&gt;

&lt;p&gt;深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。&lt;/p&gt;

&lt;h3 id=&#34;赋值和深-浅拷贝的区别&#34;&gt;赋值和深/浅拷贝的区别&lt;/h3&gt;

&lt;p&gt;这三者的区别如下，不过比较的前提都是针对引用类型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。&lt;/li&gt;
&lt;li&gt;浅拷贝：重新在堆中创建内存，拷贝前后对象的基本数据类型互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。&lt;/li&gt;
&lt;li&gt;深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝,拷贝前后的两个对象互不影响。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;浅拷贝&#34;&gt;浅拷贝&lt;/h3&gt;

&lt;p&gt;下面简单实现一个浅拷贝&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function shallowClone(obj) {
    const newObj = {};
    for(let prop in obj) {
        if(obj.hasOwnProperty(prop)){
            newObj[prop] = obj[prop];
        }
    }
    return newObj;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在JavaScript中，存在浅拷贝的现象有：&lt;/p&gt;

&lt;p&gt;Object.assign
Array.prototype.slice(), Array.prototype.concat()
使用拓展运算符实现的复制
#Object.assign&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var obj = {
    age: 18,
    nature: [&#39;smart&#39;, &#39;good&#39;],
    names: {
        name1: &#39;fx&#39;,
        name2: &#39;xka&#39;
    },
    love: function () {
        console.log(&#39;fx is a great girl&#39;)
    }
}
var newObj = Object.assign({}, fxObj);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;slice()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const fxArr = [&amp;quot;One&amp;quot;, &amp;quot;Two&amp;quot;, &amp;quot;Three&amp;quot;]
const fxArrs = fxArr.slice(0)
fxArrs[1] = &amp;quot;love&amp;quot;;
console.log(fxArr) // [&amp;quot;One&amp;quot;, &amp;quot;Two&amp;quot;, &amp;quot;Three&amp;quot;]
console.log(fxArrs) // [&amp;quot;One&amp;quot;, &amp;quot;love&amp;quot;, &amp;quot;Three&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;concat()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const fxArr = [&amp;quot;One&amp;quot;, &amp;quot;Two&amp;quot;, &amp;quot;Three&amp;quot;]
const fxArrs = fxArr.concat()
fxArrs[1] = &amp;quot;love&amp;quot;;
console.log(fxArr) // [&amp;quot;One&amp;quot;, &amp;quot;Two&amp;quot;, &amp;quot;Three&amp;quot;]
console.log(fxArrs) // [&amp;quot;One&amp;quot;, &amp;quot;love&amp;quot;, &amp;quot;Three&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;拓展运算符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const fxArr = [&amp;quot;One&amp;quot;, &amp;quot;Two&amp;quot;, &amp;quot;Three&amp;quot;]
const fxArrs = [...fxArr]
fxArrs[1] = &amp;quot;love&amp;quot;;
console.log(fxArr) // [&amp;quot;One&amp;quot;, &amp;quot;Two&amp;quot;, &amp;quot;Three&amp;quot;]
console.log(fxArrs) // [&amp;quot;One&amp;quot;, &amp;quot;love&amp;quot;, &amp;quot;Three&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;深拷贝&#34;&gt;深拷贝&lt;/h3&gt;

&lt;p&gt;常见的深拷贝方式有：&lt;/p&gt;

&lt;p&gt;_.cloneDeep()&lt;/p&gt;

&lt;p&gt;jQuery.extend()&lt;/p&gt;

&lt;p&gt;JSON.stringify()&lt;/p&gt;

&lt;p&gt;手写循环递归&lt;/p&gt;

&lt;p&gt;#_.cloneDeep()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const _ = require(&#39;lodash&#39;);
const obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
const obj2 = _.cloneDeep(obj1);
console.log(obj1.b.f === obj2.b.f);// false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jQuery.extend()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const $ = require(&#39;jquery&#39;);
const obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
const obj2 = $.extend(true, {}, obj1);
console.log(obj1.b.f === obj2.b.f); // false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JSON.stringify()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const obj2=JSON.parse(JSON.stringify(obj1));
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;但是这种方式存在弊端-会忽略undefined-symbol和函数&#34;&gt;但是这种方式存在弊端，会忽略undefined、symbol和函数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const obj = {
    name: &#39;A&#39;,
    name1: undefined,
    name3: function() {},
    name4:  Symbol(&#39;A&#39;)
}
const obj2 = JSON.parse(JSON.stringify(obj));
console.log(obj2); // {name: &amp;quot;A&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;循环递归&#34;&gt;循环递归&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function deepClone(obj, hash = new WeakMap()) {
  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
  if (typeof obj !== &amp;quot;object&amp;quot;) return obj;
  // 是对象的话就要进行深拷贝
  if (hash.get(obj)) return hash.get(obj);
  let cloneObj = new obj.constructor();
  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
  hash.set(obj, cloneObj);
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // 实现一个递归拷贝
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }
  return cloneObj;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;小结&#34;&gt;小结&lt;/h3&gt;

&lt;p&gt;前提为拷贝类型为引用类型的情况下：&lt;/p&gt;

&lt;p&gt;浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址&lt;/p&gt;

&lt;p&gt;深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JS bind、call、apply</title>
      <link>https://1060146865.github.io/2020/js-bindcallapply/</link>
      <pubDate>Thu, 30 Jul 2020 18:38:29 +0800</pubDate>
      
      <guid>https://1060146865.github.io/2020/js-bindcallapply/</guid>
      <description>

&lt;h1 id=&#34;call-apply-bind作用是改变函数执行时的上下文-简而言之就是改变函数运行时的this指向&#34;&gt;call、apply、bind作用是改变函数执行时的上下文，简而言之就是改变函数运行时的this指向&lt;/h1&gt;

&lt;h3 id=&#34;实现apply&#34;&gt;实现apply&lt;/h3&gt;

&lt;p&gt;apply接受两个参数，第一个参数是this的指向，第二个参数是函数接受的参数，以数组的形式传入&lt;/p&gt;

&lt;p&gt;改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Function.prototype.apply2 = function(context, args) {
  context = (context === undefined || context === null) ? window : context
    context.__fn = this
  let result = context.__fn(...args)
  delete context.__fn
  return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;实现call&#34;&gt;实现call&lt;/h3&gt;

&lt;p&gt;call方法的第一个参数也是this的指向，后面传入的是一个参数列表&lt;/p&gt;

&lt;p&gt;跟apply一样，改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Function.prototype.call2 = function(context, ...args) {
  context = (context === undefined || context === null) ? window : context
    context.__fn = this
  let result = context.__fn(...args)
  delete context.__fn
  return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;实现bind&#34;&gt;实现bind&lt;/h3&gt;

&lt;p&gt;bind方法和call很相似，第一参数也是this的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)&lt;/p&gt;

&lt;p&gt;改变this指向后不会立即执行，而是返回一个永久改变this指向的函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Function.prototype.bind2 = function(context, ...args1) {
  context = (context === undefined || context === null) ? window : context
    let _this = this
  return function(...args2) {
    context.__fn = _this
    let result = context.__fn(...[...args1, ...args2])
    delete context.__fn
    return result
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;apply-call-bind三者的区别在于&#34;&gt;apply、call、bind三者的区别在于：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;三者都可以改变函数的this对象指向&lt;/li&gt;
&lt;li&gt;三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window&lt;/li&gt;
&lt;li&gt;三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入&lt;/li&gt;
&lt;li&gt;bind是返回绑定this之后的函数，apply、call 则是立即执行&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>JS 数组去重</title>
      <link>https://1060146865.github.io/2020/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</link>
      <pubDate>Tue, 28 Jul 2020 18:38:29 +0800</pubDate>
      
      <guid>https://1060146865.github.io/2020/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</guid>
      <description>

&lt;h1 id=&#34;数组去重&#34;&gt;数组去重&lt;/h1&gt;

&lt;h3 id=&#34;map&#34;&gt;Map&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const arr = [3, 1, 1, 2, 5, 9, 3, 0]
const deduplication1 = arr =&amp;gt; {
  let map = new Map()
  arr.forEach(v =&amp;gt; map.set(v, 1))
  return [...map.keys()]
};
console.log(deduplication1(arr));
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;set&#34;&gt;Set&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const arr = [3, 1, 1, 2, 5, 9, 3, 0]
const deduplication2 = arr =&amp;gt; [...new Set(arr)];
console.log(deduplication2(arr))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;reduce&#34;&gt;reduce&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const arr = [3, 1, 1, 2, 5, 9, 3, 0]
const deduplication3 = arr =&amp;gt; arr.reduce((temp, v) =&amp;gt; temp.includes(v) ? temp : [...temp, v], [])

console.log(deduplication3(arr))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;filter&#34;&gt;filter&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const arr = [3, 1, 1, 2, 5, 9, 3, 0]
const deduplication4 = arr =&amp;gt; arr.filter((val, index) =&amp;gt; arr.indexOf(val) === index)
console.log(deduplication4(arr))
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>JS 数组</title>
      <link>https://1060146865.github.io/2020/js%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sun, 26 Jul 2020 17:38:29 +0800</pubDate>
      
      <guid>https://1060146865.github.io/2020/js%E6%95%B0%E7%BB%84/</guid>
      <description>

&lt;h1 id=&#34;js数组&#34;&gt;js数组&lt;/h1&gt;

&lt;p&gt;数组是一种类列表对象，它的原型中提供了遍历和修改元素的相关操作。JavaScript 数组的长度和元素类型都是非固定的。因为数组的长度可随时改变，并且其数据在内存中也可以不连续，所以 JavaScript 数组不一定是密集型的，这取决于它的使用方式。只能用整数作为数组元素的索引，而不能用字符串。&lt;/p&gt;

&lt;h1 id=&#34;创建数组&#34;&gt;创建数组&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let a =[1,2,3]
let a = new Array(&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;3&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;数组的静态方法&#34;&gt;数组的静态方法&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Array.isArray()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Array.isArray方法返回一个布尔值，表示参数是否为数组。它可以弥补typeof运算符的不足。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var arr = [1, 2, 3];

typeof arr // &amp;quot;object&amp;quot;
Array.isArray(arr) // true
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;数组的实例方法&#34;&gt;数组的实例方法&lt;/h1&gt;

&lt;h3 id=&#34;array-length&#34;&gt;Array.length&lt;/h3&gt;

&lt;p&gt;返回或设置一个数组中的元素个数。该值是一个无符号 32-bit 整数，并且总是大于数组最高项的下标。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const a =[1,2,3];
console.log(a.length);
// 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-at&#34;&gt;Array.at()&lt;/h3&gt;

&lt;p&gt;at()方法接受一个整数值并返回该索引处的项目，允许正整数和负整数。负整数从数组中的最后一项开始计数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const array1 = [5, 12, 8, 130, 44];
undefined
console.log(array1.at(3))
// 130
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-concat&#34;&gt;Array.concat()&lt;/h3&gt;

&lt;p&gt;concat()方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
const b = [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;];
const c = a.concat(b);

console.log(c);
//Array [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;f&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-copywithin&#34;&gt;Array.copyWithin()&lt;/h3&gt;

&lt;p&gt;copyWithin()方法将数组的一部分浅复制到同一数组中的另一个位置，并在不修改其长度的情况下返回它。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;返回值&lt;/code&gt;:修改后的数组。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;copyWithin&lt;/code&gt;(target, start, end)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;target&lt;/code&gt;
将序列复制到的从零开始的索引。如果为负数，target 将从最后开始计数。&lt;/p&gt;

&lt;p&gt;如果target等于或大于arr.length，则不会复制任何内容。如果target位于之后start，复制的序列将被修剪以适应arr.length。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;start&lt;/code&gt; 可选的
从零开始复制元素的索引。如果为负数， start将从最后开始计数。&lt;/p&gt;

&lt;p&gt;如果start省略，copyWithin将从 index 复制 0。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;end&lt;/code&gt; 可选的
从零开始复制元素的索引。copyWithin 复制最多但不包括end. 如果为负数，end将从最后开始计数。&lt;/p&gt;

&lt;p&gt;如果end省略，copyWithin将复制到最后一个索引（默认为arr.length）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;];

console.log(array1.copyWithin(0, 3, 4));
// expected output: Array [&amp;quot;d&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;]

console.log(array1.copyWithin(1, 3));
// expected output: Array [&amp;quot;d&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;]

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-entries&#34;&gt;Array.entries()&lt;/h3&gt;

&lt;p&gt;entries()方法返回一个新的数组迭代器对象，该对象包含数组中每个索引的键/值对。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;返回值&lt;/code&gt;: 一个新的Array迭代器对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];

const iterator1 = array1.entries();

console.log(iterator1.next().value);
// expected output: Array [0, &amp;quot;a&amp;quot;]

console.log(iterator1.next().value);
// expected output: Array [1, &amp;quot;b&amp;quot;]



使用索引和元素进行迭代
const a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];

for (const [index, element] of a.entries())
  console.log(index, element);

// 0 &#39;a&#39;
// 1 &#39;b&#39;
// 2 &#39;c&#39;


使用for…of循环
var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
var iterator = a.entries();

for (let e of iterator) {
  console.log(e);
}
// [0, &#39;a&#39;]
// [1, &#39;b&#39;]
// [2, &#39;c&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-every&#34;&gt;Array.every()&lt;/h3&gt;

&lt;p&gt;every()方法测试数组中的所有元素是否通过提供的函数实现的测试。它返回一个布尔值。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;返回值&lt;/code&gt;: true如果callbackFn函数为每个数组元素返回一个真值。否则， false。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;every(function callbackFn(element) { ... })
every(function callbackFn(element, index) { ... })
every(function callbackFn(element, index, array){ ... })
every(function callbackFn(element, index, array) { ... }, thisArg)


[12, 5, 8, 130, 44].every(x =&amp;gt; x &amp;gt;= 10);   // false
[12, 54, 18, 130, 44].every(x =&amp;gt; x &amp;gt;= 10); // true


const array1 = [1, 30, 39, 29, 10, 13];
array1.every(function e (element,index,array){
    console.log(element)
    console.log(index)
    console.log(array)
})

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-fill&#34;&gt;Array.fill()&lt;/h3&gt;

&lt;p&gt;fill()方法将数组中的所有元素更改为静态值，从开始索引（默认0）到结束索引（默认array.length）。它返回修改后的数组。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;返回值&lt;/code&gt;:修改后的数组，填充了value.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fill(value, start, end)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;value&lt;/code&gt;
用于填充数组的值。（注意数组中的所有元素都将是这个确切的值。）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;start&lt;/code&gt; 可选的
起始索引（含），默认0.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;end&lt;/code&gt; 可选的
结束索引（独占），默认arr.length.&lt;/p&gt;

&lt;p&gt;注意：Array.prototype.fill()在空数组上使用不会修改它，因为数组没有要修改的内容。
如果start为负，则将其视为array.length + start。
如果end为负，则将其视为array.length + end。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const array1 = [1, 2, 3, 4];

// fill with 0 from position 2 until position 4
console.log(array1.fill(0, 2, 4));
// expected output: [1, 2, 0, 0]

// fill with 5 from position 1
console.log(array1.fill(5, 1));
// expected output: [1, 5, 5, 5]

console.log(array1.fill(6));
// expected output: [6, 6, 6, 6]

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[1, 2, 3].fill(4)                // [4, 4, 4]
[1, 2, 3].fill(4, 1)             // [1, 4, 4]
[1, 2, 3].fill(4, 1, 2)          // [1, 4, 3]
[1, 2, 3].fill(4, 1, 1)          // [1, 2, 3]
[1, 2, 3].fill(4, 3, 3)          // [1, 2, 3]
[1, 2, 3].fill(4, -3, -2)        // [4, 2, 3]
[1, 2, 3].fill(4, NaN, NaN)      // [1, 2, 3]
[1, 2, 3].fill(4, 3, 5)          // [1, 2, 3]
Array(3).fill(4)                 // [4, 4, 4]
[].fill.call({ length: 3 }, 4)   // {0: 4, 1: 4, 2: 4, length: 3}

// A single object, referenced by each slot of the array:
let arr = Array(3).fill({}) // [{}, {}, {}]
arr[0].hi = &amp;quot;hi&amp;quot;            // [{ hi: &amp;quot;hi&amp;quot; }, { hi: &amp;quot;hi&amp;quot; }, { hi: &amp;quot;hi&amp;quot; }]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-filter&#34;&gt;Array.filter()&lt;/h3&gt;

&lt;p&gt;filter()方法创建一个新数组，其中包含通过提供的函数实现的测试的所有元素。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;返回值&lt;/code&gt;:包含通过测试的元素的&lt;code&gt;新数组&lt;/code&gt;。如果没有元素通过测试，将返回一个&lt;code&gt;空数组&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;callbackFn
函数是一个谓词，用来测试数组的每个元素。返回一个强制true保留元素的值，false否则。&lt;/p&gt;

&lt;p&gt;它接受三个参数：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;element&lt;/code&gt;
数组中正在处理的当前元素。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;index可选的&lt;/code&gt;
数组中正在处理的当前元素的索引。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;array可选的&lt;/code&gt;
该数组filter被调用。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;thisArg可选的&lt;/code&gt;
this执行时使用的值callbackFn。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;filter(function callbackFn(element, index, array) { ... }, thisArg)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const words = [&#39;spray&#39;, &#39;limit&#39;, &#39;elite&#39;, &#39;exuberant&#39;, &#39;destruction&#39;, &#39;present&#39;];

const result = words.filter(word =&amp;gt; word.length &amp;gt; 6);

console.log(result);
// expected output: Array [&amp;quot;exuberant&amp;quot;, &amp;quot;destruction&amp;quot;, &amp;quot;present&amp;quot;]

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;查找数组中的所有素数
const array = [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];

function isPrime(num) {
  for (let i = 2; num &amp;gt; i; i++) {
    if (num % i == 0) {
      return false;
    }
  }
  return num &amp;gt; 1;
}

console.log(array.filter(isPrime)); // [2, 3, 5, 7, 11, 13]



从 JSON 过滤无效条目

let arr = [
  { id: 15 },
  { id: -1 },
  { id: 0 },
  { id: 3 },
  { id: 12.2 },
  { },
  { id: null },
  { id: NaN },
  { id: &#39;undefined&#39; }
]

let invalidEntries = 0

function filterByID(item) {
  if (Number.isFinite(item.id) &amp;amp;&amp;amp; item.id !== 0) {
    return true
  }
  invalidEntries++
  return false;
}

let arrByID = arr.filter(filterByID)

console.log(&#39;Filtered Array\n&#39;, arrByID)
// Filtered Array
// [{ id: 15 }, { id: -1 }, { id: 3 }, { id: 12.2 }]

console.log(&#39;Number of Invalid Entries = &#39;, invalidEntries)
// Number of Invalid Entries = 5



在数组中搜索
let fruits = [&#39;apple&#39;, &#39;banana&#39;, &#39;grapes&#39;, &#39;mango&#39;, &#39;orange&#39;]

/**
 * Filter array items based on search criteria (query)
 */
function filterItems(arr, query) {
  return arr.filter(function(el) {
    return el.toLowerCase().indexOf(query.toLowerCase()) !== -1
  })
}

console.log(filterItems(fruits, &#39;ap&#39;))  //[&#39;apple&#39;, &#39;grapes&#39;]
console.log(filterItems(fruits, &#39;an&#39;))  //[&#39;banana&#39;, &#39;mango&#39;, &#39;orange&#39;]

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-find&#34;&gt;Array.find()&lt;/h3&gt;

&lt;p&gt;find()方法返回提供的数组中满足提供的测试函数的第一个元素的值。如果没有值满足测试函数，undefined则返回。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;返回值&lt;/code&gt;:数组中满足提供的测试函数的第一个元素 的值。否则，被退回。 undefined&lt;/p&gt;

&lt;p&gt;&lt;code&gt;find(function callbackFn(element, index, array) { ... }, thisArg)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;callbackFn
对数组中的每个值执行的函数，采用 3 个参数：&lt;/p&gt;

&lt;p&gt;element
数组中的当前元素。&lt;/p&gt;

&lt;p&gt;index 可选的
数组中当前元素的索引（位置）。&lt;/p&gt;

&lt;p&gt;array 可选的
find被调用的数组。&lt;/p&gt;

&lt;p&gt;thisArg 可选的
用作thisinside 的 对象callbackFn。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const array1 = [5, 12, 8, 130, 44];

const found = array1.find(element =&amp;gt; element &amp;gt; 10);

console.log(found);
// expected output: 12


通过其属性之一在数组中查找对象
const inventory = [
  {name: &#39;apples&#39;, quantity: 2},
  {name: &#39;bananas&#39;, quantity: 0},
  {name: &#39;cherries&#39;, quantity: 5}
];

function isCherries(fruit) {
  return fruit.name === &#39;cherries&#39;;
}

console.log(inventory.find(isCherries));
// { name: &#39;cherries&#39;, quantity: 5 }



使用箭头函数和解构
const inventory = [
  {name: &#39;apples&#39;, quantity: 2},
  {name: &#39;bananas&#39;, quantity: 0},
  {name: &#39;cherries&#39;, quantity: 5}
];

const result = inventory.find( ({ name }) =&amp;gt; name === &#39;cherries&#39; );

console.log(result) // { name: &#39;cherries&#39;, quantity: 5 }


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-findindex&#34;&gt;Array.findIndex()&lt;/h3&gt;

&lt;p&gt;findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则，它返回，表示没有元素通过测试。 -1&lt;/p&gt;

&lt;p&gt;&lt;code&gt;返回值&lt;/code&gt;:通过测试的数组中第一个元素的索引。否则， -1。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;findIndex(function callbackFn(element, index, array) { ... }, thisArg)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const array1 = [5, 12, 8, 130, 44];

const isLargeNumber = (element) =&amp;gt; element &amp;gt; 13;

console.log(array1.findIndex(isLargeNumber));
// expected output: 3


查找数组中素数的索引
function isPrime(num) {
  for (let i = 2; num &amp;gt; i; i++) {
    if (num % i == 0) {
      return false;
    }
  }
  return num &amp;gt; 1;
}

console.log([4, 6, 8, 9, 12].findIndex(isPrime)); // -1, not found
console.log([4, 6, 7, 9, 12].findIndex(isPrime)); // 2 (array[2] is 7)

使用箭头函数查找索引
const fruits = [&amp;quot;apple&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;cantaloupe&amp;quot;, &amp;quot;blueberries&amp;quot;, &amp;quot;grapefruit&amp;quot;];

const index = fruits.findIndex(fruit =&amp;gt; fruit === &amp;quot;blueberries&amp;quot;);

console.log(index); // 3
console.log(fruits[index]); // blueberries


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-flat&#34;&gt;Array.flat()&lt;/h3&gt;

&lt;p&gt;flat() 方法会按照一个可指定的深度循环数组，将所有元素与遍历到的子数组中的元素合并为一个新数组返回。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;返回值&lt;/code&gt;:一个包含将数组与子数组中所有元素的新数组。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;flat(depth)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;depth 可选的
指定嵌套数组结构应展平的深度的深度级别。默认为 1。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
const arr1 = [0, 1, 2, [3, 4]];

console.log(arr1.flat());
// expected output: [0, 1, 2, 3, 4]

const arr2 = [0, 1, 2, [[[3, 4]]]];

console.log(arr2.flat(3));
// expected output: [0, 1, 2, [3, 4]]



使用 Infinity，可展开任意深度的嵌套数组
var arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];
arr4.flat(Infinity);
// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

flat() 方法会移除数组中的空项：
var arr4 = [1, 2, , 4, 5];
arr4.flat();
// [1, 2, 4, 5]


使用reduce与concat
var arr = [1, 2, [3, 4]];

// 展开一层数组
arr.flat();
// 等效于
arr.reduce((acc, val) =&amp;gt; acc.concat(val), []);
// [1, 2, 3, 4]

// 使用扩展运算符 ...
const flattened = arr =&amp;gt; [].concat(...arr);

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-flatmap&#34;&gt;Array.flatMap()&lt;/h3&gt;

&lt;p&gt;flatMap()方法返回一个新数组，该数组通过将给定的回调函数应用于数组的每个元素，然后将结果展平一级而形成。它与深度为 1 的map() 几乎相同，但比分别调用这两个方法效率稍高。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;flatMap(function callbackFn(currentValue, index, array) { ... }, thisArg)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;map() 与 flatMap()
var arr1 = [1, 2, 3, 4];

arr1.map(x =&amp;gt; [x * 2]);
// [[2], [4], [6], [8]]

arr1.flatMap(x =&amp;gt; [x * 2]);
// [2, 4, 6, 8]

// only one level is flattened
arr1.flatMap(x =&amp;gt; [[x * 2]]);
// [[2], [4], [6], [8]]

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-foreach&#34;&gt;Array.forEach()&lt;/h3&gt;

&lt;p&gt;forEach() 方法对每个元素执行一次给定的函数。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;返回值&lt;/code&gt;:undefined&lt;/p&gt;

&lt;p&gt;&lt;code&gt;forEach(function callbackFn(element, index, array) { ... }, thisArg)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;注意：除了抛出异常以外，没有办法中止或跳出forEach()循环。如果你需要停止或跳出循环，则forEach()不是应该使用的工具。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;将 for 循环转换为 forEach
const items = [&#39;item1&#39;, &#39;item2&#39;, &#39;item3&#39;]
const copyItems = []

// before
for (let i = 0; i &amp;lt; items.length; i++) {
  copyItems.push(items[i])
}

// after
items.forEach(function(item){
  copyItems.push(item)
})


以下代码为数组中的每个元素记录一行：

function logArrayElements(element, index, array) {
  console.log(&#39;a[&#39; + index + &#39;] = &#39; + element)
}

[2, 5, , 9].forEach(logArrayElements)
// logs:
// a[0] = 2
// a[1] = 5
// a[3] = 9


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-from&#34;&gt;Array.from()&lt;/h3&gt;

&lt;p&gt;Array.from() 方法从一个类似的数组或可迭代对象创建一个新的、浅实例的实例。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;返回值&lt;/code&gt;:一个新的数组实例。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Array.from(arrayLike, function mapFn(element, index) { ... }, thisArg)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;arrayLike
要转换为数组的类数组或可迭代对象。&lt;/p&gt;

&lt;p&gt;mapFn 可选的
Map 函数调用数组的每个元素。&lt;/p&gt;

&lt;p&gt;thisArg 可选的
this执行时使用的值mapFn。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.log(Array.from(&#39;foo&#39;));
// expected output: Array [&amp;quot;f&amp;quot;, &amp;quot;o&amp;quot;, &amp;quot;o&amp;quot;]

console.log(Array.from([1, 2, 3], x =&amp;gt; x + x));
// expected output: Array [2, 4, 6]


从Set生成数组
const set = new Set([&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;, &#39;foo&#39;]);
Array.from(set);
// [ &amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot; ]

从Map生成数组
const map = new Map([[1, 2], [2, 4], [4, 8]]);
Array.from(map);
// [[1, 2], [2, 4], [4, 8]]

const mapper = new Map([[&#39;1&#39;, &#39;a&#39;], [&#39;2&#39;, &#39;b&#39;]]);
Array.from(mapper.values());
// [&#39;a&#39;, &#39;b&#39;];

Array.from(mapper.keys());
// [&#39;1&#39;, &#39;2&#39;];

从类数组对象（参数）生成数组
function f() {
  return Array.from(arguments);
}

f(1, 2, 3);

// [ 1, 2, 3 ]

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-includes&#34;&gt;Array.includes()&lt;/h3&gt;

&lt;p&gt;includes()方法确定数组是否在其条目中包含某个值，返回true或 false。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;返回值&lt;/code&gt;:一个布尔值，即true该值 searchElement是否在数组（或由 index 指示的数组部分fromIndex，如果指定）中找到。&lt;/p&gt;

&lt;p&gt;无论符号如何，零值都被认为是相等的。（即， -0被认为是等于两个0和+0），但false是不被认为是一样的0。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;includes(searchElement, fromIndex)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;searchElement
要搜索的值。&lt;/p&gt;

&lt;p&gt;注意：当比较字符串和字符， includes()是区分大小写的。&lt;/p&gt;

&lt;p&gt;fromIndex 可选的
在此数组中开始搜索的位置 searchElement。&lt;/p&gt;

&lt;p&gt;要搜索的第一个元素在fromIndex的正值处找到fromIndex，或在 arr.length + fromIndex的负值处找到 fromIndex（使用绝对值offromIndex作为从数组末尾开始搜索的元素数）。&lt;/p&gt;

&lt;p&gt;默认为0.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[1, 2, 3].includes(2)         // true
[1, 2, 3].includes(4)         // false
[1, 2, 3].includes(3, 3)      // false
[1, 2, 3].includes(3, -1)     // true
[1, 2, NaN].includes(NaN)     // true
[&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;].includes(3)   // false


如果fromIndex大于或等于数组的长度，false则返回。不会搜索数组。

let arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

arr.includes(&#39;c&#39;, 3)    // false
arr.includes(&#39;c&#39;, 100)  // false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-indexof&#34;&gt;Array.indexOf()&lt;/h3&gt;

&lt;p&gt;indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;返回值&lt;/code&gt;:首个被找到的元素在数组中的索引位置；如果没有找到则返回-1&lt;/p&gt;

&lt;p&gt;&lt;code&gt;indexOf(searchElement, fromIndex)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;searchElement
要查找的元素
fromIndex 任选
开始查找的位置。如果该索引值大于或等于整个长度，则参数可能会在数组里查找，返回-1。即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找，以此类推。仍然是从前向后查询数组。如果以后的索引值仍然小于0，则整个数组都会被查询。默认值为0。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;下面举例使用indexOf方法确定多个值在数组中的位置。

var array = [2, 5, 9];
array.indexOf(2);     // 0
array.indexOf(7);     // -1
array.indexOf(9, 2);  // 2
array.indexOf(2, -1); // -1
array.indexOf(2, -3); // 0

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-isarray&#34;&gt;Array.isArray()&lt;/h3&gt;

&lt;p&gt;Array.isArray() 用于确定传递的值是否是一个Array。&lt;/p&gt;

&lt;p&gt;返回值:true如果值是一个Array；否则， false。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Array.isArray([1, 2, 3]);  // true
Array.isArray({foo: 123}); // false
Array.isArray(&#39;foobar&#39;);   // false
Array.isArray(undefined);  // false

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-join&#34;&gt;Array.join()&lt;/h3&gt;

&lt;p&gt;join()方法通过连接数组（或类似数组的对象）中的所有元素来创建并返回一个新字符串，用逗号或指定的分隔符字符串分隔。如果数组只有一项，则将在不使用分隔符的情况下返回该项。&lt;/p&gt;

&lt;p&gt;返回值:连接了所有数组元素的字符串。如果arr.length是 0，则返回空字符串。&lt;/p&gt;

&lt;p&gt;如果一个元素为 undefined 或 null，它会被转换为空字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var a = [&#39;Wind&#39;, &#39;Water&#39;, &#39;Fire&#39;];
a.join();      // &#39;Wind,Water,Fire&#39;
a.join(&#39;, &#39;);  // &#39;Wind, Water, Fire&#39;
a.join(&#39; + &#39;); // &#39;Wind + Water + Fire&#39;
a.join(&#39;&#39;);    // &#39;WindWaterFire&#39;

连接类数组对象
function f(a, b, c) {
  var s = Array.prototype.join.call(arguments);
  console.log(s); // &#39;1,a,true&#39;
}
f(1, &#39;a&#39;, true);
//expected output: &amp;quot;1,a,true&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-keys&#34;&gt;Array.keys()&lt;/h3&gt;

&lt;p&gt;keys() 方法返回一个包含数组中索引键的Array Iterator对象。&lt;/p&gt;

&lt;p&gt;返回值:一个新的Array迭代器对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
const iterator = array1.keys();

for (const key of iterator) {
  console.log(key);
}

// expected output: 0
// expected output: 1
// expected output: 2



对应的元素会包含那些元素的索引
var arr = [&amp;quot;a&amp;quot;, , &amp;quot;c&amp;quot;];
var sparseKeys = Object.keys(arr);
var denseKeys = [...arr.keys()];
console.log(sparseKeys); // [&#39;0&#39;, &#39;2&#39;]
console.log(denseKeys);  // [0, 1, 2]

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-lastindexof&#34;&gt;Array.lastIndexOf()&lt;/h3&gt;

&lt;p&gt;lastIndexOf()方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个索引，如果不存在则返回 -1 fromIndex。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lastIndexOf(searchElement, fromIndex)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;返回值:数组中该元素最后一次出现的索引，如未找到返回-1。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const animals = [&#39;Dodo&#39;, &#39;Tiger&#39;, &#39;Penguin&#39;, &#39;Dodo&#39;];

console.log(animals.lastIndexOf(&#39;Dodo&#39;));
// expected output: 3

console.log(animals.lastIndexOf(&#39;Tiger&#39;));
// expected output: 1

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-map&#34;&gt;Array.map()&lt;/h3&gt;

&lt;p&gt;map() 方法创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;map(function callbackFn(element, index, array) { ... }, thisArg)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;返回值:一个由原每个元素执行功能的结果组成的新数组。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const array1 = [1, 4, 9, 16];

// pass a function to map
const map1 = array1.map(x =&amp;gt; x * 2);

console.log(map1);
// expected output: Array [2, 8, 18, 32]



使用 map 重新格式化数组中的对象
let kvArray = [{key: 1, value: 10},
               {key: 2, value: 20},
               {key: 3, value: 30}]

let reformattedArray = kvArray.map(obj =&amp;gt; {
   let rObj = {}
   rObj[obj.key] = obj.value
   return rObj
})
// reformattedArray is now [{1: 10}, {2: 20}, {3: 30}],

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-of&#34;&gt;Array.of()&lt;/h3&gt;

&lt;p&gt;Array.of() 方法创建一个具有数量数量参数的新数组实例，而不是考虑参数的。&lt;/p&gt;

&lt;p&gt;Array.of() 和 Array 构造函数之间的区别在于处理实例：Array.of(7) 创建一个具有单个元素7的数组，而 Array(7) 创建一个长度为7个的空数组（注意：这是指一个有7个空位（空）的数组，而不是由7个undefined组成的数组）。&lt;/p&gt;

&lt;p&gt;返回值:新的Array实例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Array.of(7);       // [7]
Array.of(1, 2, 3); // [1, 2, 3]

Array(7);          // [ , , , , , , ]
Array(1, 2, 3);    // [1, 2, 3]


Array.of(1);         // [1]
Array.of(1, 2, 3);   // [1, 2, 3]
Array.of(undefined); // [undefined]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-pop&#34;&gt;Array.pop()&lt;/h3&gt;

&lt;p&gt;pop()从数组中删除最后一个元素，并返回该元素的值。&lt;/p&gt;

&lt;p&gt;返回值:从数组中删除的元素（当数组为空时返回undefined）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const plants = [&#39;broccoli&#39;, &#39;cauliflower&#39;, &#39;cabbage&#39;, &#39;kale&#39;, &#39;tomato&#39;];

console.log(plants.pop());
// expected output: &amp;quot;tomato&amp;quot;

console.log(plants);
// expected output: Array [&amp;quot;broccoli&amp;quot;, &amp;quot;cauliflower&amp;quot;, &amp;quot;cabbage&amp;quot;, &amp;quot;kale&amp;quot;]

plants.pop();

console.log(plants);
// expected output: Array [&amp;quot;broccoli&amp;quot;, &amp;quot;cauliflower&amp;quot;, &amp;quot;cabbage&amp;quot;]


let myFish = [&amp;quot;angel&amp;quot;, &amp;quot;clown&amp;quot;, &amp;quot;mandarin&amp;quot;, &amp;quot;surgeon&amp;quot;];

let popped = myFish.pop();

console.log(myFish);
// [&amp;quot;angel&amp;quot;, &amp;quot;clown&amp;quot;, &amp;quot;mandarin&amp;quot;]

console.log(popped);
// surgeon


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-push&#34;&gt;Array.push()&lt;/h3&gt;

&lt;p&gt;push() 方法将一个或多个元素添加到汇总的详细信息中，并返回该数组的新长度。&lt;/p&gt;

&lt;p&gt;返回值:新的length属性值将被返回。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var sports = [&amp;quot;soccer&amp;quot;, &amp;quot;baseball&amp;quot;];
var total = sports.push(&amp;quot;football&amp;quot;, &amp;quot;swimming&amp;quot;);

console.log(sports);
// [&amp;quot;soccer&amp;quot;, &amp;quot;baseball&amp;quot;, &amp;quot;football&amp;quot;, &amp;quot;swimming&amp;quot;]

console.log(total);
// 4

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-reduce&#34;&gt;Array.reduce()&lt;/h3&gt;

&lt;p&gt;该reduce()方法在数组的每个元素上执行用户提供的“reducer”回调函数，传入前一个元素计算的返回值。在数组的所有元素上运行 reducer 的最终结果是单个值。&lt;/p&gt;

&lt;p&gt;也许最容易理解的情况reduce()是返回数组中所有元素的总和。&lt;/p&gt;

&lt;p&gt;reducer 逐个元素遍历数组，在每一步将当前数组值添加到上一步的结果（此结果是所有先前步骤的运行总和）——直到没有更多元素要添加。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;返回值&lt;/code&gt;:函数累积处理的结果&lt;/p&gt;

&lt;p&gt;&lt;code&gt;reduce(function callbackFn(previousValue, currentValue, currentIndex, array) { ... }, initialValue)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;callback
执行数组中每个值（没有提供 initialValue则第一个值除外）的函数，包括四个参数：
accumulator
累积累积次数的返回值；是上一次调用时间返回的累计值，或initialValue（见底下）。&lt;/p&gt;

&lt;p&gt;currentValue
数组中正在处理的元素。
index 任选
数组中正在处理的当前元素的索引initialValue。
array任选
调用reduce()的数组
initialValue任选
第作为一次调用 callback函数时的第一个参数的值。如果没有提供初始值，则将使用数组中的第一个元素。在没有初始值的空数组上调用减少将报错。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;累加对象数组里的值
var initialValue = 0;
var sum = [{x: 1}, {x:2}, {x:3}].reduce(function (accumulator, currentValue) {
    return accumulator + currentValue.x;
},initialValue)

console.log(sum) // logs 6

将二维数组转化为一维
var flattened = [[0, 1], [2, 3], [4, 5]].reduce(
  function(a, b) {
    return a.concat(b);
  },
  []
);
// flattened is [0, 1, 2, 3, 4, 5]


计算每个元素出现的次数
var names = [&#39;Alice&#39;, &#39;Bob&#39;, &#39;Tiff&#39;, &#39;Bruce&#39;, &#39;Alice&#39;];

var countedNames = names.reduce(function (allNames, name) {
  if (name in allNames) {
    allNames[name]++;
  }
  else {
    allNames[name] = 1;
  }
  return allNames;
}, {});
// countedNames is:
// { &#39;Alice&#39;: 2, &#39;Bob&#39;: 1, &#39;Tiff&#39;: 1, &#39;Bruce&#39;: 1 }


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-reduceright&#34;&gt;Array.reduceRight()&lt;/h3&gt;

&lt;p&gt;reduce()方法和reduceRight()方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，reduce()是从左到右处理（从第一个成员到最后一个成员），reduceRight()则是从右到左（从最后一个成员到第一个成员），其他完全一样。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;reduceRight(function callbackFn(accumulator, currentValue, index, array) { ... }, initialValue)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;返回值&lt;/code&gt;:执行后的返回值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;总结一个数组中的所有值
var sum = [0, 1, 2, 3].reduceRight(function(a, b) {
  return a + b;
});
// sum is 6

展平一个数组
var flattened = [[0, 1], [2, 3], [4, 5]].reduceRight(function(a, b) {
    return a.concat(b);
}, []);
// flattened is [4, 5, 2, 3, 0, 1]


reduce和之间的区别reduceRight

var a = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;];
var left  = a.reduce(function(prev, cur)      { return prev + cur; });
var right = a.reduceRight(function(prev, cur) { return prev + cur; });

console.log(left);  // &amp;quot;12345&amp;quot;
console.log(right); // &amp;quot;54321&amp;quot;


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-reverse&#34;&gt;Array.reverse()&lt;/h3&gt;

&lt;p&gt;reverse() 方法将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。该方法会改变原数组。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;arr.reverse()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;返回值:颠倒后的数组&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const a = [1, 2, 3];

console.log(a); // [1, 2, 3]

a.reverse();

console.log(a); // [3, 2, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-shift&#34;&gt;Array.shift()&lt;/h3&gt;

&lt;p&gt;shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。&lt;/p&gt;

&lt;p&gt;arr.shift()&lt;/p&gt;

&lt;p&gt;&lt;code&gt;返回值&lt;/code&gt; :从数组中删除的元素; 如果数组为空则返回undefined 。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;以下代码显示了删除其第一个元素之前和之后的myFish数组。它还显示已删除的元素：

let myFish = [&#39;angel&#39;, &#39;clown&#39;, &#39;mandarin&#39;, &#39;surgeon&#39;];

console.log(&#39;调用 shift 之前: &#39; + myFish);
// &amp;quot;调用 shift 之前: angel,clown,mandarin,surgeon&amp;quot;

var shifted = myFish.shift();

console.log(&#39;调用 shift 之后: &#39; + myFish);
// &amp;quot;调用 shift 之后: clown,mandarin,surgeon&amp;quot;

console.log(&#39;被删除的元素: &#39; + shifted);
// &amp;quot;被删除的元素: angel&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-slice&#34;&gt;Array.slice()&lt;/h3&gt;

&lt;p&gt;slice()方法将数组的一部分的浅拷贝返回到一个新的数组对象中，该对象从startto end （end不包括）中选择，其中start和end表示该数组中项目的索引。不会修改原始数组。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;slice(start, end)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;begin&lt;/code&gt; 可选
提取起始处的索引（从 0 开始），从该索引开始提取原数组元素。
如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。
如果省略 begin，则 slice 从索引 0 开始。
如果 begin 超出原数组的索引范围，则会返回空数组。
&lt;code&gt;end&lt;/code&gt; 可选
提取终止处的索引（从 0 开始），在该索引处结束提取原数组元素。slice 会提取原数组中索引从 begin 到 end 的所有元素（包含 begin，但不包含 end）。
slice(1,4) 会提取原数组中从第二个元素开始一直到第四个元素的所有元素 （索引为 1, 2, 3的元素）。
如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1) 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。
如果 end 被省略，则 slice 会一直提取到原数组末尾。
如果 end 大于数组的长度，slice 也会一直提取到原数组末尾。&lt;/p&gt;

&lt;p&gt;返回值:一个含有被提取元素的新数组。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
const animals = [&#39;ant&#39;, &#39;bison&#39;, &#39;camel&#39;, &#39;duck&#39;, &#39;elephant&#39;];

console.log(animals.slice(2));
// expected output: Array [&amp;quot;camel&amp;quot;, &amp;quot;duck&amp;quot;, &amp;quot;elephant&amp;quot;]

console.log(animals.slice(2, 4));
// expected output: Array [&amp;quot;camel&amp;quot;, &amp;quot;duck&amp;quot;]

console.log(animals.slice(1, 5));
// expected output: Array [&amp;quot;bison&amp;quot;, &amp;quot;camel&amp;quot;, &amp;quot;duck&amp;quot;, &amp;quot;elephant&amp;quot;]

console.log(animals.slice(-2));
// expected output: Array [&amp;quot;duck&amp;quot;, &amp;quot;elephant&amp;quot;]

console.log(animals.slice(2, -1));
// expected output: Array [&amp;quot;camel&amp;quot;, &amp;quot;duck&amp;quot;]


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-some&#34;&gt;Array.some()&lt;/h3&gt;

&lt;p&gt;some()方法测试数组中是否至少有一个元素通过了提供的函数实现的测试。如果在数组中找到一个元素，提供的函数为其返回真，则返回真；否则返回false。它不会修改数组。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;some(function callbackFn(element, index, array) { ... }, thisArg)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;callbackFn
用于测试每个元素的函数，采用三个参数：&lt;/p&gt;

&lt;p&gt;element
数组中正在处理的当前元素。&lt;/p&gt;

&lt;p&gt;index可选的
数组中正在处理的当前元素的索引。&lt;/p&gt;

&lt;p&gt;array可选的
该数组some()被调用。&lt;/p&gt;

&lt;p&gt;thisArg可选的
this执行时使用的值callbackFn。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;返回值&lt;/code&gt;:true如果回调函数返回数组中至少一个元素的真值。否则，false。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意：如果用一个空数组进行测试，在任何情况下它返回的都是false。&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;[2, 5, 8, 1, 4].some(x =&amp;gt; x &amp;gt; 10);  // false
[12, 5, 8, 1, 4].some(x =&amp;gt; x &amp;gt; 10); // true

判断数组元素中是否存在某个值
var fruits = [&#39;apple&#39;, &#39;banana&#39;, &#39;mango&#39;, &#39;guava&#39;];

function checkAvailability(arr, val) {
  return arr.some(function(arrVal) {
    return val === arrVal;
  });
}

checkAvailability(fruits, &#39;kela&#39;);   // false
checkAvailability(fruits, &#39;banana&#39;); // true


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-sort&#34;&gt;Array.sort()&lt;/h3&gt;

&lt;p&gt;sort() 方法用原地算法对数组的元素进行排序，并返回数组。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sort(function compareFn(firstEl, secondEl) { ... })&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;返回值:排序后的数组。请注意，数组已原地排序，并且不进行复制。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
[10111, 1101, 111].sort(function (a, b) {
  return a - b;
})
// [111, 1101, 10111]

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-splice&#34;&gt;Array.splice()&lt;/h3&gt;

&lt;p&gt;splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;splice(start, deleteCount, item1, item2, itemN)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;返回值&lt;/code&gt;:由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，&lt;code&gt;则返回空数组&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;从索引 0 的位置开始删除 2 个元素，插入&amp;quot;parrot&amp;quot;、&amp;quot;anemone&amp;quot;和&amp;quot;blue&amp;quot;

var myFish = [&#39;angel&#39;, &#39;clown&#39;, &#39;trumpet&#39;, &#39;sturgeon&#39;];
var removed = myFish.splice(0, 2, &#39;parrot&#39;, &#39;anemone&#39;, &#39;blue&#39;);

// 运算后的 myFish: [&amp;quot;parrot&amp;quot;, &amp;quot;anemone&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;trumpet&amp;quot;, &amp;quot;sturgeon&amp;quot;]
// 被删除的元素: [&amp;quot;angel&amp;quot;, &amp;quot;clown&amp;quot;]



&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-tolocalestring&#34;&gt;Array.toLocaleString()&lt;/h3&gt;

&lt;p&gt;toLocaleString() 返回一个字符串表示数组中的元素。数组中的元素将使用各自的 toLocaleString 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 &amp;ldquo;,&amp;ldquo;）隔开。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;toLocaleString(locales, options);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;返回值&lt;/code&gt;:表示数组元素的字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const array1 = [1, &#39;a&#39;, new Date(&#39;21 Dec 1997 14:12:00 UTC&#39;)];
const localeString = array1.toLocaleString(&#39;en&#39;, { timeZone: &#39;UTC&#39; });

console.log(localeString);
// expected output: &amp;quot;1,a,12/21/1997, 2:12:00 PM&amp;quot;,
// This assumes &amp;quot;en&amp;quot; locale and UTC timezone - your results may vary
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-tostring&#34;&gt;Array.toString()&lt;/h3&gt;

&lt;p&gt;toString() 返回一个字符串，表示指定的数组及其元素。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;arr.toString()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;返回值&lt;/code&gt;:一个表示指定的数组及其元素的字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const array1 = [1, 2, &#39;a&#39;, &#39;1a&#39;];

console.log(array1.toString());
// expected output: &amp;quot;1,2,a,1a&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-unshift&#34;&gt;Array.unshift()&lt;/h3&gt;

&lt;p&gt;unshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;unshift(element0, element1, ... , elementN)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;返回值:当一个对象调用该方法时，返回其 length 属性值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;let arr = [4,5,6];
arr.unshift(1,2,3);
console.log(arr); // [1, 2, 3, 4, 5, 6]

arr = [4,5,6]; // 重置数组
arr.unshift(1);
arr.unshift(2);
arr.unshift(3);
console.log(arr); // [3, 2, 1, 4, 5, 6]


&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;array-values&#34;&gt;Array.values()&lt;/h3&gt;

&lt;p&gt;values() 方法返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值&lt;/p&gt;

&lt;p&gt;返回值:一个新的 Array 迭代对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
const iterator = array1.values();

for (const value of iterator) {
  console.log(value);
}

// expected output: &amp;quot;a&amp;quot;
// expected output: &amp;quot;b&amp;quot;
// expected output: &amp;quot;c&amp;quot;


&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>JS 的运算符和数据类型转换</title>
      <link>https://1060146865.github.io/2020/js%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Fri, 24 Jul 2020 16:38:29 +0800</pubDate>
      
      <guid>https://1060146865.github.io/2020/js%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <description>

&lt;h1 id=&#34;运算符&#34;&gt;运算符&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;算术运算符&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+, -, *, /, %&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一般用来计算数值&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;+&lt;/code&gt;号任意一边出现字符时，+号的功能就是字符拼接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-, *, /, %&lt;/code&gt;会将两边的数据作为数值型数据计算&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关系（比较）运算符&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;, &amp;gt;=, &amp;lt;, &amp;lt;=, ==, ===, !=, !==&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;==&lt;/code&gt; 如果两边操作数相等时返回true。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!=&lt;/code&gt; 如果两边操作数不相等时返回true&lt;/li&gt;
&lt;li&gt;&lt;code&gt;===&lt;/code&gt; 两边操作数相等且类型相同时返回true。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!==&lt;/code&gt; 两边操作数不相等或类型不同时返回true。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;赋值运算符&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;=, +=, -=, *=, /=, %=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=&lt;/code&gt;表示将右侧的数据放在左侧的变量中，重复赋值会覆盖原值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+=, -=, *=, /=, %=&lt;/code&gt;的规则请参考算术运算符&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;逻辑运算符&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;或：||&lt;/li&gt;
&lt;li&gt;且（与）：&amp;amp;&amp;amp;&lt;/li&gt;
&lt;li&gt;非：!&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一元运算符&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;++&lt;/code&gt;：自增1，在自身原有基础上增加1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--&lt;/code&gt;：自减1，在自身原有基础上减少1&lt;/li&gt;
&lt;li&gt;前(++i)：先计算，后使用&lt;/li&gt;
&lt;li&gt;后(i++)：先使用，再计算&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;隐式类型转换&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;计算过程中不按照原本的数据类型计算，而是默认作为其他数据类型计算，该过程称为数据&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;数据类型转换&#34;&gt;数据类型转换&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;隐式类型转换：计算过程中不按照原本的数据类型计算，而是作为其他数据类型计算&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;场景：

&lt;ol&gt;
&lt;li&gt;运算符&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;规则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;- * /&lt;/code&gt; 在对各种非Number类型运用数学运算符(- * /)时，会先将非Number类型转换为Number类型。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;+&lt;/code&gt; 可以用来拼接字符串。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当一侧为String类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。&lt;/li&gt;
&lt;li&gt;当一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型。&lt;/li&gt;
&lt;li&gt;当一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后拼接。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 if while for 语句时，我们期望表达式是一个Boolean，所以一定伴随着隐式类型转换。而这里面又分为两种情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果只有单个变量，会先将变量转换为Boolean值。 &lt;code&gt;只有 null undefined &#39;&#39; NaN 0 false 这几个是 false，其他的情况都是 true，比如 {} , []。&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 == 比较中的5条规则&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;规则 1：NaN和其他任何类型比较永远返回false（包括和他自己）。 &lt;code&gt;NaN == NaN // false&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;规则 2：Boolean 和其他任何类型比较，Boolean 首先被转换为 Number 类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;true == 1  // true 
true == &#39;2&#39;  // false, 先把 true 变成 1，而不是把 &#39;2&#39; 变成 true
true == [&#39;1&#39;]  // true, 先把 true 变成 1， [&#39;1&#39;]拆箱成 &#39;1&#39;, 再参考规则3
true == [&#39;2&#39;]  // false, 同上
undefined == false // false ，首先 false 变成 0，然后参考规则4
null == false // false，同上
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;规则 3：String和Number比较，先将String转换为Number类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;123 == &#39;123&#39; // true, &#39;123&#39; 会先变成 123
&#39;&#39; == 0 // true, &#39;&#39; 会首先变成 0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;规则 4：null == undefined比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;规则 5：原始类型和引用类型做比较时，引用类型会依照ToPrimitive规则转换为原始类型。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ToPrimitive规则，是引用类型向原始类型转变的规则，它遵循先valueOf后toString的模式期望得到一个原始类型。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果还是没法得到一个原始类型，就会抛出 TypeError。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;[object Object]&#39; == {} 
// true, 对象和字符串比较，对象通过 toString 得到一个基本类型值
&#39;1,2,3&#39; == [1, 2, 3] 
// true, 同上  [1, 2, 3]通过 toString 得到一个基本类型值
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;显示（强制）类型转换&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;其他转数值：

&lt;ul&gt;
&lt;li&gt;规则

&lt;ul&gt;
&lt;li&gt;严格转换：必须全部为数字，才能转成数值，否则NaN

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;hello&amp;rdquo; &amp;mdash; NaN&lt;/li&gt;
&lt;li&gt;&amp;ldquo;123a12&amp;rdquo; &amp;mdash; NaN&lt;/li&gt;
&lt;li&gt;&amp;ldquo;12312&amp;rdquo; &amp;mdash; 12312&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;非严格转换：从左向右检测，遇到第一个非数字的字符，停止转换；第一个字符就非数字，直接NaN

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;123a12&amp;rdquo; &amp;mdash; 123&lt;/li&gt;
&lt;li&gt;&amp;ldquo;hello&amp;rdquo; &amp;mdash; NaN&lt;/li&gt;
&lt;li&gt;&amp;ldquo;a1231&amp;rdquo; &amp;mdash; NaN&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;方法：

&lt;ul&gt;
&lt;li&gt;parseInt()

&lt;ul&gt;
&lt;li&gt;非严格转换，不能识别小数点&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;parseFloat()

&lt;ul&gt;
&lt;li&gt;非严格转换，能识别小数点&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Math.round()

&lt;ul&gt;
&lt;li&gt;严格转换，四舍五入取最近的整数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Number()

&lt;ul&gt;
&lt;li&gt;严格转换，能识别小数点&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;其他转布尔：

&lt;ul&gt;
&lt;li&gt;规则：

&lt;ul&gt;
&lt;li&gt;字符：非空字符为true，空为false&lt;/li&gt;
&lt;li&gt;数值：非0为true，0为false&lt;/li&gt;
&lt;li&gt;对象数组函数：都是true&lt;/li&gt;
&lt;li&gt;undefined,null,NaN：都是false&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;方法

&lt;ul&gt;
&lt;li&gt;Boolean()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;其他转字符：

&lt;ul&gt;
&lt;li&gt;规则：

&lt;ul&gt;
&lt;li&gt;默认，类似于直接给数据添加引号&lt;/li&gt;
&lt;li&gt;保留n为小数，存在四舍五入&lt;/li&gt;
&lt;li&gt;对象默认转成：[object Object]&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;方法：

&lt;ul&gt;
&lt;li&gt;num.toString();&lt;/li&gt;
&lt;li&gt;num.toFixed(n);&lt;/li&gt;
&lt;li&gt;String();&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;一些补充&#34;&gt;一些补充&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;关于NaN&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NaN：not a Number，不是一个数字&lt;/li&gt;
&lt;li&gt;数据类型是：数值型&lt;/li&gt;
&lt;li&gt;表示非法的运算，或错误的转换&lt;/li&gt;
&lt;li&gt;如何判断是不是NaN

&lt;ul&gt;
&lt;li&gt;isNaN(要检测的数据或变量)

&lt;ul&gt;
&lt;li&gt;true：是NaN&lt;/li&gt;
&lt;li&gt;false：不是NaN&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;NaN与任何数据都不相等&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关于计算机中的小数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;浮点数的精度问题&lt;/li&gt;
&lt;li&gt;因为计算中的数据在运算时会被转成二进制，计算结束后又会从二进制转回十进制&lt;/li&gt;
&lt;li&gt;二进制中也存在无限数字，计算系统的位数有限，省略某些位数，导致一些小数的计算不精确&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>JS 函数的执行时机</title>
      <link>https://1060146865.github.io/2020/js-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</link>
      <pubDate>Tue, 21 Jul 2020 15:38:29 +0800</pubDate>
      
      <guid>https://1060146865.github.io/2020/js-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</guid>
      <description>

&lt;h1 id=&#34;1-为什么如下代码会打印-6-个-6&#34;&gt;1.为什么如下代码会打印 6 个 6&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;let i = 0
for(i = 0; i&amp;lt;6; i++){
  setTimeout(()=&amp;gt;{
    console.log(i)
  },0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为setTimeout的意思是稍后执行，也就是在等for循环结束之后再执行console.log(i)，当for结束循环的时候i等于6，且只有1个i，所以打印出6个6&lt;/p&gt;

&lt;h1 id=&#34;2-如何让以上代码打印出0-6&#34;&gt;2.如何让以上代码打印出0&amp;ndash;6&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;for(let i=0;i&amp;lt;6;i++){
setTimeout(()=&amp;gt;{
console.log(i)
},0)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为JS在for和let一起用的时候会在每次循环的时候多创建一个i，每次循环都会重新创建一个i，所以会打印出0，1，2，3，4，5&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
let i
for(i = 0; i&amp;lt;6; i++){
    const x = i
    setTimeout(()=&amp;gt;{
      console.log(x)
    })
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
let i 
for(i = 0; i&amp;lt;6; i++){
  !function(j){
      setTimeout(()=&amp;gt;{
        console.log(j)
      },0)
  }(i)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
for(var i=0;i&amp;lt;6;i++){
            (function(i){
                setTimeout(()=&amp;gt;{console.log(i)},0)
            })(i)
        }

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;let i = 0
for(i = 0; i&amp;lt;6; i++){
setTimeout((i)=&amp;gt;{
console.log(i)
},0,i)
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>JS 对象基本用法</title>
      <link>https://1060146865.github.io/2020/js-%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</link>
      <pubDate>Wed, 01 Jul 2020 22:14:26 +0800</pubDate>
      
      <guid>https://1060146865.github.io/2020/js-%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</guid>
      <description>

&lt;h1 id=&#34;js-对象基本用法&#34;&gt;JS 对象基本用法&lt;/h1&gt;

&lt;h1 id=&#34;声明对象的方法&#34;&gt;声明对象的方法&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;let obj ={&#39;name&#39;:&#39;zz&#39;,&#39;age&#39;:18}  //简单

let obj =new Object({&#39;name&#39;:&#39;zz&#39;,&#39;age&#39;:18}) //规范

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;注意&lt;/li&gt;
&lt;li&gt;键名是字符串，不是标识符，可以包含任意字符&lt;/li&gt;
&lt;li&gt;引号可以省略，省略之后只能写标识符，键名有空格是不可以省略&lt;/li&gt;
&lt;li&gt;就算引号省略了，键名还是字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;奇怪的属性值&#34;&gt;奇怪的属性值&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;所有属性名都会自动变成字符串&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let obj ={
1:&#39;a&#39;,
1e2:true,//会自动计算后再转为字符串
0XXF:false //会自动转化为10进制再转为字符串} 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;隐藏属性&#34;&gt;隐藏属性&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JS里每个对象都有一个隐藏属性&lt;/li&gt;
&lt;li&gt;这个隐藏属性储存着其共有属性组成的对象的地址&lt;/li&gt;
&lt;li&gt;这个共有属性组成的对象叫做原型&lt;/li&gt;

&lt;li&gt;&lt;p&gt;也就是说隐藏属性储存着原型的地址&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj{}
obj.toString()//不报错
因为obj的隐藏属性对应的对象上有toString
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;原型&#34;&gt;原型&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;每个对象都有原型&lt;/li&gt;
&lt;li&gt;原型里存着对象的共有属性&lt;/li&gt;
&lt;li&gt;比如obj的原型就是一个对象&lt;/li&gt;
&lt;li&gt;obj._proto__存着这个对象的地址&lt;/li&gt;
&lt;li&gt;这个对象里有toString/constructor/valueOf等属性&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对象的原型也是对象&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对象的原型也有原型&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;obj={}的原型即为所有对象的原型&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这个原型包含所有对象的共有属性，是对象的根&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这个原型也有也有原型，是null&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;删除对象的属性&#34;&gt;删除对象的属性&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;obj.name = undefined  //只删除属性值
delete obj.name  //删除属性名和属性值
delete obj[&#39;name&#39;] //删除属性名和属性值
&#39;name&#39; in obj //检查obj是否含有属性名
&#39;name&#39; in obj &amp;amp;&amp;amp; obj.xxx ===undefined //有属性名，但是但是值为undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;查看对象的属性&#34;&gt;查看对象的属性&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;Object.keys(obj)   //读取对象自身所有的属性 
Object.values(obj)  //读取对象的属性值 
Object.entries(obj)  //读取对象的属性名和属性值,得到是length个数组
 console.dir(obj)或者obj.__proto__ (不推荐) //读取共有属性
&#39;toString&#39; in obj //检查是否有这个属性,自身属性和共有属性都算
obj.hasOwnProperty(&#39;name&#39;) //检查这个属性是否是自身属性
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;查看属性方法&#34;&gt;查看属性方法&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;中括号语法：obj[&amp;lsquo;key&amp;rsquo;]  //推荐&lt;/li&gt;
&lt;li&gt;点语法：obj.key&lt;/li&gt;
&lt;li&gt;其它 ：obj[key]  //key值是一个变量是使用此语法&lt;/li&gt;

&lt;li&gt;&lt;p&gt;注obj[&amp;lsquo;name&amp;rsquo;] == obj.name != obj[name] //name 是字符串&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let name = &#39;zzz&#39;
obj[name]==obj[&#39;zzz&#39;] //obj[xxx] xxx这个变量，不是一个字符串。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;增加对象的属性&#34;&gt;增加对象的属性&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;let obj = {name:&#39;zzz&#39;}
obj.name = &#39;zzz&#39;
obj[&#39;name&#39;] =&#39;zzz&#39;
obj.[&#39;na&#39;+&#39;me&#39;] =&#39;zzz&#39;
let key = &#39;name&#39; obj[key] ==&#39;zzz&#39;

错误 obj[name] =&#39;zzz&#39; --因为name是一个变量

Object.assign(obj,{name:&#39;zzz&#39;,age:18})  //批量赋值
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;修改对象的属性&#34;&gt;修改对象的属性&lt;/h1&gt;

&lt;h3 id=&#34;无法通过自身修改或增加共有属性&#34;&gt;无法通过自身修改或增加共有属性&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;obj.toString = &#39;xxx&#39;    只会在改 obj 自身属性
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;一般不要修改修改原型的共有属性&#34;&gt;一般不要修改修改原型的共有属性&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;obj.__proto__.toString =&#39;zzz&#39; //不推荐使用 __proto__

window.Object.prototype.toString = &#39;zzz&#39;

let obj = Object.create(common)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;name-in-obj和obj-hasownproperty-name-的区别&#34;&gt;&amp;lsquo;name&amp;rsquo; in obj和obj.hasOwnProperty(&amp;lsquo;name&amp;rsquo;) 的区别&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;in 自身属性和共有属性都返回true&lt;/li&gt;
&lt;li&gt;hasOwnProperty 是自身属性才返回true ,不会去判断原型&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>JS的基本语法</title>
      <link>https://1060146865.github.io/2020/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Mon, 29 Jun 2020 18:58:55 +0800</pubDate>
      
      <guid>https://1060146865.github.io/2020/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid>
      <description>

&lt;h1 id=&#34;什么是表达式和语句&#34;&gt;什么是表达式和语句&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;var a = 1 + 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;1 + 3&lt;/code&gt;叫做表达式,表达式不需要分号结尾。语句以分号结尾，一个分号就表示一个语句结束。&lt;/p&gt;

&lt;p&gt;语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。&lt;/p&gt;

&lt;h1 id=&#34;标识符的规则&#34;&gt;标识符的规则&lt;/h1&gt;

&lt;p&gt;标识符指的是用来识别各种值的合法名称。&lt;/p&gt;

&lt;p&gt;标识符命名规则如下&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。&lt;/li&gt;
&lt;li&gt;第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;if-else-语句&#34;&gt;if else 语句&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;if (m === 1) {
  // 满足条件时，执行的语句
} else {
  // 不满足条件时，执行的语句
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对同一个变量进行多次判断时，多个if&amp;hellip;else语句可以连写在一起。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (m === 0) {
  // ...
} else if (m === 1) {
  // ...
} else if (m === 2) {
  // ...
} else {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;switch-语句&#34;&gt;switch 语句&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;switch (x) {
  case 1:
    console.log(&#39;x 等于1&#39;);
    break;
  case 2:
    console.log(&#39;x 等于2&#39;);
    break;
  default:
    console.log(&#39;x 等于其他值&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;case代码块之中没有break语句，导致不会跳出switch结构，而会一直执行下去。&lt;/p&gt;

&lt;h1 id=&#34;while-语句&#34;&gt;while 语句&lt;/h1&gt;

&lt;p&gt;While语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while (条件) {
  语句;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。&lt;/p&gt;

&lt;h1 id=&#34;for-语句&#34;&gt;for 语句&lt;/h1&gt;

&lt;p&gt;for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (初始化表达式; 条件; 递增表达式) {
  语句
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;break-continue&#34;&gt;break continue&lt;/h1&gt;

&lt;p&gt;break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。&lt;/p&gt;

&lt;p&gt;break语句用于跳出代码块或循环。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(i = 1; i &amp;lt;= 10; i++){
    if(i === 5){
        break;
    }
    console.log(i);
}

会输出 1 2 3 4 
后面的就不输出了
i === 5 就退出所有循环
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for(i = 1; i &amp;lt;= 10; i++){
    if(i === 5){
        continue;
    }
    console.log(i);
}

会输出 1 2 3 4   6 7 8 9 10
i === 5 就退出当前一次循环，接着继续输出6 7 8 9 10
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;label&#34;&gt;label&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;foo:{
    console.log(1);
    break foo;
    console.log(&#39;本行不会输出&#39;);
}
console.log(2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;标签通常与break语句和continue语句配合使用，跳出特定的循环。&lt;/p&gt;

&lt;h1 id=&#34;问号冒号表达式-三元运算符&#34;&gt;问号冒号表达式(三元运算符）&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;(条件) ? 表达式1 : 表达式2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;“条件”为true，则返回“表达式1”的值，否则返回“表达式2”的值。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript 的诞生</title>
      <link>https://1060146865.github.io/2020/javascript-%E7%9A%84%E8%AF%9E%E7%94%9F/</link>
      <pubDate>Mon, 08 Jun 2020 17:17:13 +0800</pubDate>
      
      <guid>https://1060146865.github.io/2020/javascript-%E7%9A%84%E8%AF%9E%E7%94%9F/</guid>
      <description>

&lt;h1 id=&#34;javascript-的诞生&#34;&gt;JavaScript 的诞生&lt;/h1&gt;

&lt;p&gt;1994 年，网景公司（Netscape）发布了 Navigator 浏览器0.9版。这是历史上第一个比较成熟的网络浏览器，轰动一时。但是，这个版本的浏览器只能用来浏览，不具备与访问者互动的能力。网景公司急需一种网页脚本语言，使得浏览器可以与网页互动。&lt;/p&gt;

&lt;p&gt;当时的形势就是，网景公司的整个管理层，都是 Java 语言的信徒，Sun 公司完全介入网页脚本语言的决策。&lt;/p&gt;

&lt;p&gt;此时，34 岁的系统程序员 Brendan Eich 登场了。1995 年 4 月，网景公司录用了他。&lt;/p&gt;

&lt;p&gt;Brendan Eich 的主要方向和兴趣是函数式编程，网景公司招聘他的目的，是研究将 Scheme 语言作为网页脚本语言的可能性。Brendan Eich 本人也是这样想的，以为进入新公司后，会主要与 Scheme 语言打交道。&lt;/p&gt;

&lt;p&gt;仅仅一个月之后，1995年5月，网景公司做出决策，未来的网页脚本语言必须”看上去与 Java 足够相似”，但是比 Java 简单，使得非专业的网页作者也能很快上手。这个决策实际上将 Perl、Python、Tcl、Scheme 等非面向对象编程的语言都排除在外了。&lt;/p&gt;

&lt;p&gt;Brendan Eich 被指定为这种”简化版Java语言”的设计师。&lt;/p&gt;

&lt;p&gt;但是，他对 Java 一点兴趣也没有。为了应付公司安排的任务，他只用 10 天时间就把 Javascript 设计出来了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;“与其说我爱 Javascript，不如说我恨它。它是 C 语言和 Self 语言一夜情的产物。十八世纪英国文学家约翰逊博士说得好：’它的优秀之处并非原创，它的原创之处并不优秀。’” ——Brendan Eich&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;就是这样一个连发明这门语言的人都不待见，只用了 10 天时间草草完工的语言竟然成了世界上使用最广泛的语言之一，实在是充满了传奇色彩。&lt;/p&gt;

&lt;h1 id=&#34;javascript-的历史&#34;&gt;JavaScript 的历史&lt;/h1&gt;

&lt;p&gt;它最初由Netscape的Brendan Eich设计。JavaScript是甲骨文公司的注册商标。Ecma国际以JavaScript为基础制定了ECMAScript标准。JavaScript也可以用于其他场合，如服务器端编程。完整的JavaScript实现包含三个部分：ECMAScript，文档对象模型，浏览器对象模型。&lt;/p&gt;

&lt;p&gt;Netscape在最初将其脚本语言命名为LiveScript，后来Netscape在与Sun合作之后将其改名为JavaScript。JavaScript最初受Java启发而开始设计的，目的之一就是“看上去像Java”，因此语法上有类似之处，一些名称和命名规范也借自Java。但JavaScript的主要设计原则源自Self和Scheme。JavaScript与Java名称上的近似，是当时Netscape为了营销考虑与Sun微系统达成协议的结果。尽管JavaScript作为给非程序人员的脚本语言，而非作为给程序人员的脚本语言来推广和宣传，但是JavaScript具有非常丰富的特性。&lt;/p&gt;

&lt;p&gt;发展初期，JavaScript的标准并未确定，同期有Netscape的JavaScript，微软的JScript和CEnvi的ScriptEase三足鼎立。1997年，在ECMA（欧洲计算机制造商协会）的协调下，由Netscape、Sun、微软、Borland组成的工作组确定统一标准：ECMA-262。&lt;/p&gt;

&lt;h1 id=&#34;javascript缺陷&#34;&gt;JavaScript缺陷&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/06/10_design_defects_in_javascript.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.ruanyifeng.com/blog/2011/06/10_design_defects_in_javascript.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>浅析URL</title>
      <link>https://1060146865.github.io/2020/%E6%B5%85%E6%9E%90url/</link>
      <pubDate>Mon, 25 May 2020 19:36:56 +0800</pubDate>
      
      <guid>https://1060146865.github.io/2020/%E6%B5%85%E6%9E%90url/</guid>
      <description>

&lt;h1 id=&#34;url&#34;&gt;URL&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;URL(Uniform Resource Locator)：统一资源定位符&lt;/li&gt;
&lt;li&gt;URL的组成：协议+域名+端口+路径+查询参数+锚点&lt;/li&gt;
&lt;li&gt;URL举例：&lt;a href=&#34;https://www.baidu.com/s?wd=URL&amp;amp;rsv_spt=1#5&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.baidu.com/s?wd=URL&amp;amp;rsv_spt=1#5&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;协议：https ，在Internet中可以使用多种协议，如HTTP，FTP等等。&lt;/li&gt;
&lt;li&gt;域名：www.baidu.com&lt;/li&gt;
&lt;li&gt;路径：/s&lt;/li&gt;
&lt;li&gt;查询参数：?wd=URL&amp;amp;rsv_spt=1&lt;/li&gt;
&lt;li&gt;锚点：“#”开始到最后，都是锚点（不在network中显示，只和本地有关）&lt;/li&gt;
&lt;li&gt;端口：http的默认端口是80，https的默认端口是443&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ip&#34;&gt;IP&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;IP(Internet protocol)：网络协议&lt;/li&gt;
&lt;li&gt;IP的两个作用

&lt;ul&gt;
&lt;li&gt;定位一台设备&lt;/li&gt;
&lt;li&gt;定义了如何封装数据，以及和其他设备交流&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;与IP协议配套使用的还有四个协议

&lt;ul&gt;
&lt;li&gt;地址解析协议（Address Resolution Protocol，ARP）&lt;/li&gt;
&lt;li&gt;逆地址解析协议（Reverse Address Resolution Protocol，RARP）&lt;/li&gt;
&lt;li&gt;网际控制报文协议（Internet Control Message Protocol，ICMP）&lt;/li&gt;
&lt;li&gt;网际组管理协议（Internet Group Management Protocol，IGMP）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;dns&#34;&gt;DNS&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;DNS(Domain Name System):域名系统协议&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;进行主机名到IP地址的转换&lt;/li&gt;
&lt;li&gt;主机别名：有些主机的主机名比较复杂，可以为该主机起多个简单易记的别名。应用程序可以调用DNS来获得主机别名对应的规范主机名（不是别名的主机名）及主机的IP地址&lt;/li&gt;
&lt;li&gt;负载分配：DNS允许用同一个主机名对应一个IP地址集合。DNS服务器收到该主机名的解析请求时，随机或循环返回地址集合中的一个地址。一些热门网站，可以利用该服务将网站复制到多个服务器上，这些服务器共用同一个域名，从而实现在这些服务器上的负载分配。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;方向域名解析：有时某些应用需要将某个IP地址转换为域名，这可以通过方向域来实现。&lt;/p&gt;

&lt;h1 id=&#34;域名&#34;&gt;域名&lt;/h1&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;域名就是IP的别称，一个域名可以对应不同IP，一个IP可以对应不同域名。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;域名的结构由若干个分量组成，各分量之间用.隔开&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;…….三级域名.二级域名.顶级域名
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;域名等级&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;国家顶级域名：cn,us&lt;/li&gt;
&lt;li&gt;通用顶级域名：com,net,org,int,edu,gov,mil&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://1060146865.github.io/images/tupian/url.png&#34; alt=&#34;avatar&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>